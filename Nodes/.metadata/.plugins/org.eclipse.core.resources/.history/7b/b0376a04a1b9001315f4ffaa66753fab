/*
 * gearshfting.c
 *
 *  Created on: Mar 17, 2014
 *      Author: Zeyang Geng
 */

#include "gearshifting.h"

//How to go neutrual
// may be press both for long time


/********** GLOBAL DEFINATION **********/
unsigned int gearPosition = 0;
bool gearIsInPosition = false;
bool problem = false;

int shiftUpTime = 0;
int shiftDownTime = 0;

const unsigned short shiftLevelsHigh[7] =
	{NEUTRALHIGH, GEAR1HIGH, GEAR2HIGH, GEAR3HIGH, GEAR4HIGH, GEAR5HIGH, GEAR6HIGH};
const unsigned short shiftLevelsLow[7] =
	{NEUTRALLOW, GEAR1LOW, GEAR2LOW, GEAR3LOW, GEAR4LOW, GEAR5LOW, GEAR6LOW};

/***************************************/
void init_actuators()
{
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Pin =CLUTCH|SHIFT_UP|SHIFT_DOWN;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
	GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
	GPIO_Init(GEAR_SHIFT_PORT, &GPIO_InitStructure);
}

void actuate(GPIO_TypeDef* port,uint16_t system)
{
	GPIO_SetBits(port,system);
}


void release(GPIO_TypeDef* port,uint16_t system)
{
	GPIO_ResetBits(port,system);
}

//how to call actuator and read ADC value
//
//actuate(GEAR_SHIFT_PORT,SHIFT_UP)
//
//gear = rawAnalogState[]
//
//Digital input
//gearup digIn[0] = 1
//geardown digIn[1] = 1


/****************************************/


void gearShiftManager(void) {

	static unsigned int shiftUpUsedTime = 0;
	static unsigned int shiftDownUsedTime = 0;

	static unsigned int shiftDownHoldingTime = 0;

	int shiftUpSwitch, shiftDownSwitch;
	bool shiftUpActive, shiftDownActive, goToNeutralActive;

	unsigned int sensorMonitor = 0;

	gearIsInPosition = GearIsInPosition();
	gearPosition = GetGearPosition();

	if (!gearIsInPosition){
			sensorMonitor++;
	}else{
		if(problem){
			realse(GEAR_SHIFT_PORT,CLUTCH);
			sensorMonitor = 0;
		}
	}

	if (sensorMonitor > MONITOR_TIME){
		actuate(GEAR_SHIFT_PORT,CLUTCH);
		problem = true;
		//put it into higher position
	    sensorMonitor = 0;
	}

//	shiftUpSwitch = digIn[0];
//	shiftDownSwitch = digIn[1];

	if(!digIn[0] && !digIn[1]){
		shiftUpActive = false;
		shiftDownActive = false;
		goToNeutralActive = false;
		shiftDownSwitchHoldingTime = 0;
		shiftUpUsedTime = 0;
		shiftDownUsedTime = 0;
		goToNeutralUsedTime = 0;

		return;
	}

	if(digIn[0]){
		gearIsInPosition = GearIsInPosition();
		gearPosition = GetGearPosition();

		if(gearIsInPosition){
			if(gearPosition = 0){//now is in neutral
				shiftDownActive = true;
				shiftUpActive = false;
				goToNeutral = false;
			}elseif(gearPosition > 2){//in gear 3 or over gear

			}else{
				shiftUpActive = true;
				shiftDownActive = false;
				goToNeutralActive = false;
			}
		}

		//shiftUpUsedTime = shiftUpUsedTime + HoldingTime;
		//TODO
	}

	while(digIn[1]){
		shiftDownSwitchHoldingTime++;
	}

	if(shiftDownSwitchHoldingTime > SwWITCHHOLDINGTIME){
		//holding shift down for long time mean go to neutral

		shiftDownSwitchHoldingTime = 0;
		goToNeutralActive = true;
		shiftUpActive = false;
		shiftDownActive = false;

	}else{
		shiftDownSwitchHoldingTime = 0;
		shiftDownActive = true;
		shiftUpActive = false;
		goToNeutralActive = false;
	}

	if(shiftUpActive){
		ShiftUp(gearPosition);
	}

	if(shiftDownActive){
		ShiftDown(gearPosition);
	}

	if(goToNeutralActive){
		GoToNeutral();
	}

}

bool GearIsInPosition(void){
	uint16_t gearPositionSensorData = rawAnalogState[1];

	for(int i = 0 ; i < 7 ; i++){
		if (gearPositionSensorData > shiftLevelsLow[i] && gearPositionSensorData < shiftLevelsHigh[i]){
			return true;
		}
	}

	return false;
}

Int GetGearPosition(){

	uint16_t gearPositionSensorData = rawAnalogState[1];

	int gearPosition = 0;
	for(int i = 0 ; i < 7 ; i++){
		if (gearPositionSensorData > shiftLevelsLow[i] && gearPositionSensorData < shiftLevelsHigh[i]){
			gearPosition = i;
			gearIsInPosition = true;
			break;
			}

		if (gearPositionSensorData > shiftLevelsHigh[i] && gearPositionSensorData < shiftLevelsLow[i+1]){
			gearPosition = i;
			gearIsInPosition = false;
			break;
			}
	}

	return gearPosition;

}

//first do slow but safe shift up
void ShiftUp(int gearPosition){

	actuate(GEAR_SHIFT_PORT,SHIFT_UP);

	//int gearCylinderPositionCurrent = 0;
	int gearPositionCurrent = 0;

	/*
	for(int cylinderPositionMonitor = 0 ; ; cylinderPositionMonitor++){
		gearCylinderPositionCurrent = GetGearCylinderPosition();
		//TODO Ashfaq
		delay(100);
		//TODO Ashfaq
		if (gearCylinderPositionCurrent < NATURAL_CYLINDER_POSITION){
			//cylinder start to move up
			//TODO PT
			CutIgnition();
			break;
		}

		if(cylinderPositionMonitor>MONITOR_TIME){
			//after active the cylinder doesn't move
			//TODO PT
		}
	}
    */
	for(int gearPositionMonitor = 0 ; ; gearPositionMonitor++){
		gearPositionCurrent = GetGearPosition();
		//TODO Ashfaq
		delay(100);

		//TODO Ashfaq
		if(gearPositionCurrent = gearPosition + 1){
			RestoreIgnition();
			break;
		}

		if(gearPositionMonitor>MONITOR_TIME){


			//after cylinder move the gear cannot reach next level
			//TODO PT
		}
	}

	//ReleaseCylinder
	//TODO Ashfaq

	return;
}

void ShiftDown(int gearPosition){
	actuate(GEAR_SHIFT_PORT,CLUTCH);

	for(int i = 0 ; i< 50; i++){
		;
	}
	shiftDownTime = shiftDownTime + 50;

	actuate(GEAR_SHIFT_PORT,SHIFT_DOWN);

	int gearPositionCurrent = 0;

	for(int gearPositionMonitor = 0 ; ; gearPositionMonitor++){
		gearPositionCurrent = GetGearPosition();
		for(int i = 0 ; i< 50; i++){
				;
			}
		shiftDownTime = shiftDownTime + 50;
		if(gearPositionCurrent = gearPosition - 1){
			break;
		}
		if(gearPositionMonitor > MONITOR_TIME){
			gearPositionMonitor = 0;

		}
	}

	release(GEAR_SHIFT_PORT,CLUTCH);
	release(GEAR_SHIFT_PORT,SHIFT_DOWN);

	return;
}

void GoToNeutral(void){
	//give out neutral cylinder signal
	//TODO Ashfaq

	//how can we know that the neutral cylinder is in position?
	//Or wait for some time to let it in position?
	//what if this one failed
	//TODO Toni

	//give out shiftup signal
	//TODO Ashfaq

	int gearPositionCurrent = 0;

	for(int gearPositionMonitor = 0 ; ; gearPositionMonitor++){
		gearPositionCurrent = GetGearPosition();
		//TODO Ashfaq
		delay(100);
		//TODO Ashfaq
		if(gearPositionCurrent = 0){
			//release gear
		}

	}
}

void CutIgnition(void){

}

void RestoreIgnition(void){

}

void ElClutch(void){

}

uint16_t GetGearCylinderPosition(void){
	return rawAnalogState[2];
}

uint16_t GetGearPositionSensorData(void){

}
